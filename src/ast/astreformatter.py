

class ASTReformatter():
  '''General purpose class for reformatting an abstract syntax tree (AST)
  generated by the astconverter/astfilter module

  Uses 'function_names' to identify nodes that contain specified function
  names and creates a list of all those nodes for pattern mining.
  '''
  def __init__(self, args):
    self.function_names = args.keys()
    self.func_args = args
    self.output_structure = []
    
  def run(self, filtered_ast):
    '''Returns a list of ast nodes. 

    Reformatted AST entails a list of nodes that contains functions specified by
    'self.function_names'.

    Example:

    function_names = ['test1', 'test2']
    args = {
      'test1': ['arg1'],
      'test2': ['x']
    }

    and given an AST generated from the source
    'test1(test2(x = 1, y = 2), 3, arg1 = 4)'

    yields
    [
      {
        "type": "call",
        "function": "test",
        "args": [
          {
            "type": "call",
            "function": "test2",
            "args": [],
            "keywords": [
              {
                "keyword": "x",
                "value": "1"
              }
            ]
          }
        ],
        "keywords": [
          {
            "keyword": "arg1",
            "value": "4"
          }
        ]
      },
      {
        "type": "call",
        "function": "test2",
        "args": [],
        "keywords": [
          {
            "keyword": "x",
            "value": "1"
          }
        ]
      }
    ]
    In this case, test1 is returned because it is specified in
    'function_names'. The arguments 'test2' and 'arg1 = 4' are kept because
    they are a call argument (i.e., a function call) and a specified argument
    name, respectively. Additionally, 'test2' is added to the list because it
    is a function that is specified in 'function_names'.
    '''

    self.search_ast(filtered_ast)
    return self.output_structure

  def search_ast(self, filtered_ast):
    '''Encapsulating function that searches out calls and function_defs fields
    in the AST and adds the appropriate call nodes to the output_structure list.
    '''
    calls = filtered_ast['calls']
    for call in calls:
      self.search_call(call)

    function_defs = filtered_ast['function_defs']
    for function_def in function_defs:
      self.search_function_def(function_def)
  
  def search_value(self, value):
    '''Acts as a 'dispatch' function that calls the appropriate search
    function based on value type, searches the value for 'call' nodes that
    are specified in 'function_names'.
    '''
    if isinstance(value, dict) and 'type' in value.keys():
      if value['type'] == 'call':
        self.search_call(value)
      elif value['type'] == 'list' or value['type'] == 'set' or value['type'] == 'tuple':
        self.search_iterable(value)
      elif value['type'] == 'dict':
        self.search_dict(value)

  def search_iterable(self, iterable):
    '''Encapsulating function that searches the elements of 'set', 'list',
    and 'tuple' nodes for 'call' nodes that are specified in 'function_names'.
    '''
    for element in iterable['elements']:
      self.search_value(element)

  def search_dict(self, dict):
    '''Encapsulating function that searches the key value pairs of 'dict' nodes
    for 'call' nodes that are specified in 'function_names'.
    '''
    for key, value in dict['key_values']:
      self.search_value(key)
      self.search_value(value)

  def search_function_name(self, instance):
    if isinstance(instance, dict):
      if 'instance' in instance.keys():
        call_name = self.search_function_name(instance['instance'])
        if instance['attr'] in self.function_names:
          return instance['attr']
        return call_name
      else:
        return self.search_value(instance)
    elif isinstance(instance, str) and instance in self.function_names:
      return instance
    return None

  def search_call(self, call):
    '''Encapsulating function that checks if the call is specified in
    'function_names' and searches the arguments and keywords of 'call'
    nodes for functions specified in 'function_names'.
    '''
    if isinstance(call['function'], str) and call['function'] in self.function_names:
      args = []
      for arg in call['args']:
        is_valid_arg = isinstance(arg, dict) and 'type' in arg.keys() and arg['type'] == 'constant'
        if not is_valid_arg:
          return
        else:
          arg['value'] = arg['value']['value']
          args.append(arg)

      keywords = []
      keyword_keys = []
      for keyword in call['keywords']:
        is_valid_keyword = isinstance(keyword['value'], dict) and 'type' in keyword['value'].keys() and keyword['value']['type'] == 'constant'
        if not is_valid_keyword:
          return
        else:
          keyword_keys.append(keyword['keyword'])
          keyword['value'] = keyword['value']['value']
          keywords.append(keyword)

      if len(set(keyword_keys)) != len(set(self.func_args[call['function']])):
        return

      call['args'] = args
      call['keywords'] = keywords
      self.output_structure.append(call)
    else:
      self.search_function_name(call['function'])
    for arg in call['args']:
      self.search_value(arg)
    for keyword in call['keywords']:
      self.search_value(keyword['value'])

  def search_function_def(self, func_def):
    '''Encapsulating function that searches the calls field of 'function_def'
    nodes for functions specified in 'function_names'.
    '''
    for call in func_def['calls']:
      self.search_call(call)

